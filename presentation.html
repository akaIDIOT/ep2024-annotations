<!DOCTYPE html>
<html>
  <head>
    <title>Those annotations can have things other than typing?!</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      p img {
        max-width: 100%;
        max-height: 100%;
      }
      .remark-slide-content { font-size: 32px; }
      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
        font-size: inherit;
      }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

Those annotations can have things other than typing?!
=====================================================

Mattijs Ugen

---

whoami
======

- data engineer @ Netherlands Forensic Institute, The Hague
- use a lot of Python in our day-to-day
  - see [Threat to Life: Preventing Planned Murders with Python](https://www.youtube.com/watch?v=rrckKR305TU) @ EP2023

---

Those annotations can have things other than typing?!
=====================================================

> Annotating functions with typing information is commonplace nowadays. 
> Annotations have become synonymous with typing information, even though they could be just about anything youâ€™d want. 
> Are there use cases for function annotations other than typing? Is that useful? 

--

> Should you care? 

--

> *Should you stop using typing? ðŸ˜±*

---

Should you stop using typing?
=============================

## no!

--

## if you like using typing, use it!

---

So what are we talking about?
=============================

~~~ python
@cache
def calculate_thing(argument: bytes, n: int = 1) -> float:
    ...
~~~

---

So, typing, right?
==================

![PEP 3107](images/pep-3107.png)

---

So, typing, right?
==================

![typing module, introduced in Python 3.5](images/docs-module-typing.png)

---

Right, so what elseâ€¦
====================

~~~ python
def H(b):
    ...

def schnorr(M, x):
    ...
    e = H(r + M)
    s = k + e * x
    return s, e
~~~

*example only, please don't assume this is correct*

---

~~~ python
def digest(data):
    ...

def schnorr(message, private_key):
    ...
    signature_right = digest(exponent_nonce + message)
    signature_left = nonce + signature_right * private_key
    return signature_left, signature_right
~~~

---

~~~ python
def digest(data: bytes) -> int:
    ...

def schnorr(message: bytes, private_key: int) -> tuple[bytes, bytes]:
    ...
    signature_right = digest(exponent_nonce + message)
    signature_left = nonce + signature_right * private_key
    return signature_left, signature_right
~~~

---

Translation into a different domain
===================================

~~~ python
def digest(data: bytes) -> 'H':
    ...

def schnorr(message: 'M', private_key: 'x') -> ('s', 'e'):
    ...
    signature_right: 'e' = digest(exponent_nonce + message)
    signature_left: 's' = nonce + signature_right * private_key
    return signature_left, signature_right
~~~

---

Translation into a different domain
===================================

- flake8 is a lot happier
- both math and python domains represented
- *annotations used as documentation*

---

Guarding function inputs
========================

- function bodies often contain input validation
- how about we just annotate what's valid?

~~~ python
def schnorr(message: binary(max_size=4096, multiple_of=16),
            private_key: number(domain='Z', max=q)):
    ...
~~~

---

Guarding function inputs
========================

- no magic 'hook' to *do* the validation
- the interpreter ignores annotationsâ€¦
- if only python had a neat way to wrap a functionâ€¦

---

Guarding function inputs
========================

~~~ python
def guard(function):
    arguments = get_annotations(function)

    def wrapped(*args, **kwargs):
        # match arguments to args and kwargs
        # validate the guards with the values
        result = function(*args, **kwargs)
        # validate result with return guard
        return result

    return wrapped
~~~

---

Guarding function inputs
========================

~~~ python
@guard  # decorator will wrap the function, providing our 'hook'
def schnorr(message: binary(max_size=4096, multiple_of=16),
            private_key: number(domain='Z', max=q)):
    ...
~~~

---

~~~ python
@dataclass
class IPv6Packet(DataStruct, BigEndian):
    source: '16s'
    destination: '16s'
    checksum: 'I'
    ...
~~~

---

Compatibility with typing
=========================

- can be complicated or impossible
- potential with `@guard` example
  - `if typing.TYPE_CHECKING: ...`
  - decorator can be a no-op
  - parameters guards can return applicable types

---

Takeaways
=========

- annotations are just python

--

- any expression will do

--

- not all of them will make sense

--

- but there's more than typing

--

- â€¦
- if you want there to be ðŸ˜Ž

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({
        ratio: "16:9",
      });
    </script>
  </body>
</html>
